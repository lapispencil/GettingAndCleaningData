makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
m = makeCacheMatrix(x)
m
get()
get
help()
exit
exit()
help
help
Q
str(get)
exit
str()
str(get)
Q
Q
asdasdasdasd
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
m
x
m$get()
cacheSolve(m)
cacheSolve(m)
## Programming Assignment 2 - Lexical Scoping
#The first function, makeCacheMatrix creates a special matrix, which is really a list
#containing a function to
# 1. set the value of the matrix
# 2. get the value of the matrix
# 3. set the value of inverse of the matrix
# 4. get the value of inverse of the matrix
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get,
setinverse=setinverse,
getinverse=getinverse)
}
## The second function returns the inverse of the matrix. It first checks to see if the inverse
## has already been calculated. If so, it gets the inverse from the cache and  skips the
## computation. Otherwise, it calculates the inverse, sets the value in the cache via
## the setinverse function.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
# Sample computation:
#
x <- matrix(10:7, nrow=2, ncol=2)
x
mk <- makeCacheMatrix()
cacheSolve(mk)
m <- makeCacheMatrix()
cacheSolve(m)
mk <- makeCacheMatrix(x)
x <- matrix(10:7, nrow=2, ncol=2)
x
mk <- makeCacheMatrix(x)
cacheSolve(mk)
cacheSolve(mk)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL #initializes value of matrix inverse as NULL
#function to set value of matrix object:
set <- function(y){
x <<- y
i <<- NULL  #sets value of matrix inverse as NULL
#for when the matrix is changed/re-set
}
#function to get value of matrix object:
get <- function() x
#function to set/cache the inverse of matrix object
setinverse <- function(solve) i <<- solve
#function to get cached inverse of matrix object
getinverse <- function() i
list (set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve: This function computes the inverse of the special "matrix"
## returned by makeCacheMatrix above. If the inverse has already been
## calculated (and the matrix has not changed), then cacheSolve should
## retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
i <- x$getinverse() #gets the cached inverse of the matrix x
#checks if there's a cached inverse, i.e., cached inverse is not NULL
if(!is.null(i)) {
#prints message to console to inform user that there's
#a cached inverse and it will be returned
message("getting cached data")
return(i)
}
data <- x$get()  #gets value of matrix x
i <- solve(data, ...) #calculates matrix inverse
x$setinverse(i) #sets value of matrix inverse
i #returns inverse
}
Rprof(lm)
swirl()
library(swirl)
swirl()
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
names(plants)
head(plants)
head(plants, nrows=10)
head(plants, 10)
tail(plants, 15)
summary(plants)
table(plants$Active_Growth_Period)
str(plants)
?sample
sample(1:6, 4, replace = TRUE)
sample(1:6, 4, replace = TRUE)
sample(1:20, 10)
LETTERS
sample(LETTERS)
sample(c(0,1),100, replace=TRUE,prob = c(0.3, 0.7))
flips <- sample(c(0,1),100, replace=TRUE,prob = c(0.3, 0.7))
flips
sum(flips)
?rbinom
rbinom(1, size = 100, prob = 0.7)
flip2 <- rbinom(100, size = 100, prob = 0.7)
flip2 <- rbinom(100, size = 1, prob = 0.7)
flips2 <- rbinom(n = 100, size = 1, prob = 0.7)
flips2
sum(flips2)
?rnorm
rnorm(10)
rnorm(10, 100, 25)
?rpois
rpois(5, 10)
my_pois <- replicate(100, rpois(5, 10))
my_pois
cm <- colMeans(my_poist)
cm <- colMeans(my_pois)
hist(cm)
getwd()
library(jsonlite)
apidata <- fromJSON("https://api.github.com/users/jtleek/repos")
apidata
str(apidata)
head(apidata)
summary(apidata)
names(apidata)
apidata$owner$login
apidata$owner$fork
apidata$owner
myapi <- toJSON(iris, pretty=TRUE)
cat(myapi)
iris2 <- fromJSON(myapi)
head(iris2)
library(data.table)
DT
DT <- data.table(x=rnorm(10), rep(c("a","b","c"), each=3),z=rnorm(9))
DT <- data.table(x=rnorm(9), rep(c("a","b","c"), each=3),z=rnorm(9))
head(DT,3)
head(DT)
tables()
DT[3,]
DT[,2]
DT[1,2]
DT[DT$y="a"]
DT[DT$y="a",]
DT[DT$y=="a",]
rnorm(300)
library(swirl)
install_from_swirl("Getting and Cleaning Data")
install_from_swirl("Getting and Cleaning Data")
install_from_swirl("Getting and Cleaning Data")
library(swirl)
install_from_swirl("Getting and Cleaning Data")
swirl()
mydf <- read.csv(path2csv, stringsAsFactors=FALSE)
dim(mydf)
head(mydf)
library(dplyr)
packageVersion("dplyr")
cran <- tb1_df(mydf)
cran <- tbl_df(mydf)
rm("mydf")
cran
?select
select(cran, ip_id, package, country)
5:20
select(cran, r_arch:country)
select(cran, country:r_arch)
cran
rm
args(rm)
install.packages('RMySQL',type='source')
install.packages("RMySQL")
library(RMySQL)
install.packages("DBI")
library(RMySQL)
library(DBI)
library(RMySQL)
View(apidata)
ucscDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.ucsc.edu")
result <- dbGetQuery(ucscDb, "show databses;"); dbDisconnect(ucscDb);
result <- dbGetQuery(ucscDb, "show databases;"); dbDisconnect(ucscDb);
result
hg19 <- dbConnect(MySQL(), user="genome", db="hg19", host="genome-mysql.cse.ucsc.edu")
allTables <- dbListTables(hg19)
length(allTables)
allTables[1:5]
dbListFields(hg19,"affyU133Plus2")
dbGetQuery(hg19, "select count(*)from affyU133Plus2")
affyData <- dbReadTable(hg19, "affyU133Plus2")
warnings()
head(affyData)
query <- dbSendQuery(hg19, "select * from affyU133Plus2 where misMatches between 1 and 3")
affyMis <- fetch(query); quantile(affyMis$misMatches)
affyMisSmall <- fetch(query, n=10); dbClearResult(query);
dim(affyMisSmall)
dbDisconnect(hg19)
source("http://bioconductor.org/biocLite.R")
biocLite("rhdf5")
library(rhdf5)
created = h5createFile("example.h5")
created
library(rhdf5)
created
str(created)
created = h5createGroup("example.h5", "foo")
A = matrix(1:10, nr=5, nc=2)
A
h5write(A, "example.h5", "foo/A")
A
created
example
example.h5
readA = h5read("example.h5", "foo/A")
readA
con = url("http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en")
con
htmlCode = readlines(con)
htmlCode = readLines(con)
close(con)
htmlCode
library(XML)
url <- "http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en"
html <- htmlTreeParse(url, useInternalNodes = T)
url <- "https://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en"
html <- htmlTreeParse(url, useInternalNodes = T)
url <- "http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en"
html <- htmlTreeParse(url, useInternalNodes = T)
library(httr); html2 = GET(url)
content2 = content(html2, as="text")
parsedHtml = htmlParse(content2, asText=TRUE)
xpathSApply(parsedHtml, "//title", xmlValue)
pg2 = GET("http://httpbin.org/basic-auth/user/passwd", authenticate("user","passwd"))
pg2
library(plyr)
X <- data.frame("var1"=sample(1:5),"var2"=sample(6:10),"var3"=sample(11:15))
X
X <- X[sample(1:5),]; X$var2[c(1,3)]=NA
X
X[,1]
X[,2]
X[,3]
X[1,]
x[,"var3"]
X[,"var3"]
X[1:2,"var3"]
X[X$var1 <=3 | X$var3 >15]
X[X$var1 <=3 | X$var3 >15,]
str(X)
X[order(X$var3,X$var1),]
X[order(X$var3),]
arrange(X,var1)
arrange(X,var3)
X$var4 <- rnorm(5)
X
Y <- cbind(X, rnorm(5))
Y
restData
library(faraway)
data(faraway)
data("warpbreaks")
str(warpbreaks)
warpbreaks$replicate <- rep(1:9, len=54)
xt <- xtabs(breaks ~ .,data=warpbreaks)
head(xt, n=3)
head(xt)
str(warpbreaks)
rep(1:9)
rep(1:9, len=15)
warpbreaks
ftable(xt)
xt
rnorm(1e5)
fakedata = rnorm(1e5)
object.size(fakedata)
print(object.size(fakedata), units="Mb")
Clear all
?rm
rm(list=ls())
library(reshape2)
head(mtcars)
mtcars$carname <- rownames(mtcars)
mtcars
head(mtcars)
carMelt <- melt(mtcars, id=c("carname","gear","cyl"), measure.vars = c("mpg", "hp")
)
head(carMelt, n =3)
head(mtcars)
carMelt
cylData <- dcast(carMelt, cyl ~ variable)
cylData
swirl()
library(swirl)
swirl()
library(swirl)
swirl()
library(dplyr)
cran <- tbl_df(mydf)
rm("mydf")
cran
?group_by
by_package <- group_by(cran, package)
by_package
summarize(by_package, mean(size))
?n
?n_distinct
x <- sample(1:10, 1e5, rep = TRUE)
length(unique(x))
n_distinct(x)
submit()
pack_sum
play()
z <- c(1:5, rep=3)
z
n_distinct(z)
nxt()
quantile(pack_sum$count, probs = 0.99)
play()
quantile(select(pack_sum, count), probs = 0.99)
nxt()
top_counts <- filter(pack_sum, count>679)
top_counts
View(top_counts)
top_counts_sorted <- arrange(top_counts, count)
top_counts_sorted <- arrange(top_counts, desc(count))
View(top_counts_sorted)
quantile(pack_sum$unique, probs = 0.99)
play()
?quantile
nxt()
top_unique <- filter(pack_sum, unique>465)
View(top_unique)
top_unique_sorted <- arrange(top_unique, desc(unique))
View(top_unique_sorted)
submit()
submit()
?chain
submit()
View(result3)
submit()
submit()
submit()
submit()
submit()
submit()
library(tidyr)
students
?gather
gather(students, sex, count, -grade)
students2
res <- gather(students2, key = "sex_class", value = "value")
res <- gather(students2, key = "sex_class", value = "value", -grade)
res <- gather(students2, sex_class, value, -grade)
res <- gather(students2, sex_class, count, -grade)
res
?separate
separate(data = res, col = sex_class, into = c("sex", "class"))
submit()
students3
library(lubridate)
install.packages("lubridate")
library(lubridate)
mdy(09051988)
mdy("09051988")
ymd("09051988")
version
version
ls()
version
update.packages(checkBuilt = TRUE)
library(tidyr)
install.packages("tidyr")
library(data.table)
library(reshape2)
library(dplyr)
getwd()
setwd("./R")
list.files()
setwd("./Module 3")
list.files()
conPath <- file.path(getwd(), "UCI HAR Dataset")
list.files(conPath, recursive = TRUE)
trainSubject <- fread(file.path(conPath, "train", "subject_train.txt"))
testSubject <- fread(file.path(conPath, "test", "subject_test.txt"))
trainActivity <- fread(file.path(conPath, "train", "Y_train.txt"))
testActivity <- fread(file.path(conPath, "test", "Y_test.txt"))
readfile <- function(file) {
datafile <- read.table(file)
datatable <- data.table(datafile)
}
traindata <- readfile(file.path(conPath, "train", "X_train.txt"))
testdata <- readfile(file.path(conPath, "test", "X_test.txt"))
subject <- rbind(trainSubject, testSubject)
setnames(subject, "V1", "subject")
activity <- rbind(trainActivity, testActivity)
setnames(activity, "V1", "activityNum")
traintest <- rbind(traindata, testdata)
subject <- cbind(subject, activity)
traintest <- cbind(subject, traintest)
setkey(traintest, subject, activityNum)
Features <- fread(file.path(conPath, "features.txt"))
setnames(Features, names(Features), c("Number", "featureDesc"))
Fmeanstd <- Features[grepl("mean\\(\\)|std\\(\\)", featureDesc)]
Fmeanstd$featureCode <- Fmeanstd[, paste0("V", Number)]
head(Fmeanstd)
subs <- c(key(traintest), Fmeanstd$featureCode)
traintest <- traintest[, subs, with = FALSE]
activitynames <- fread(file.path(conPath, "activity_labels.txt"))
setnames(activitynames, names(activitynames), c("activityNum", "activityName"))
traintest <- merge(traintest, activitynames, by = "activityNum", all.x = TRUE)
setkey(traintest, subject, activityNum, activityName)
traintest <- data.table(melt(traintest, key(traintest), variable.name = "featureCode"))
traintest <- merge(traintest, Fmeanstd[, list(Number, featureCode, featureDesc)], by = "featureCode", all.x = TRUE)
traintest$activity <- factor(traintest$activityName)
traintest$feature <- factor(traintest$featureDesc)
seq(1,3)
matrix(seq(1,3), nrow=3)
matrix(c(grepthis("^t"), grepthis("^f")), ncol = nrow(2))
grepthis <- function(regex) {
grepl(regex, traintest$feature)
}
matrix(c(grepthis("^t"), grepthis("^f")), ncol = nrow(2))
y <- matrix(seq(1, n), nrow = n)
rm(x)
rm(z)
n <- 2
y <- matrix(seq(1, n), nrow = n)
matrix(c(grepthis("^t"), grepthis("^f")), ncol = nrow(2))
matrix(c(grepthis("^t"), grepthis("^f")), ncol = nrow(y))
